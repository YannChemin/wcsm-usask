#
# This is the server logic of a Shiny web application. You can run the 
# application by clicking 'Run App' above.
#
# Find out more about building applications with Shiny here:
# 
#    http://shiny.rstudio.com/
#

library(shiny)
library(shinythemes)
library(deSolve)
library(Cairo)
library(ggplot2)
library(oce)
library(insol)
library(ggrepel)
library(leaflet)
library(leaflet.extras)
source('wcsmR2_functions.R')
source('wcsmR2.R')
coeff = read.csv('input_coefficients.csv',header=F)
coeff[is.na(coeff[,3]),3] = 0
coeff[is.na(coeff[,4]),4] = 370
coeff[is.na(coeff[,5]),5] = 50
coeff[is.na(coeff[,6]),6] = 13.5
coeff[is.na(coeff[,7]),7] = "unknown"
coeff[is.na(coeff[,8]),8] = "unknown"

# Define server logic required to draw a histogram
shinyServer(function(input,output,session) {
  val <- reactiveValues(data = read.csv(file='wcsmR2_Data_crownTemp_calendar_date.csv'),x_coord=0,plotTitle='Norstar')
  output$seedDate = renderUI(dateInput('seedDate','Seeding Date',as.Date(val$data$t[1])))
  out <- reactive({
    #temps = val$data
    daylengths = daylengths()
    DT <- 1
    time <- 1:length(val$data[,1])
    temps = data.frame(t=time,crownTemp=val$data[,2])
    Y <-
      c(
        LT50raw = -3,
        minLT50 = -3,
        dehardAmt = 0,
        dehardAmtStress = 0,
        # mflnFraction = 0,
        photoReqFraction = 0,
        accAmt = 0,
        vernDays = 0,
        vernProg = 0,
        respProg = 0
    )
    ode(
      func = model,
      y = Y,
      times = time,
      parms = c(
        photoCoeff = input$photoCoeff,
        # minDD = input$minDD,
        photoCritical = input$photoCritical,
        vernReq = input$vernReq,
        initLT50 = -3.0,
        LT50c = input$LT50c
      ),
      method = 'euler',
      daylengths=daylengths,
      crownTemps = temps
    )
  })
  daylengths <- reactive({
    if(dim(val$data)[2] == 3)
      return(val$data[,3])
#    jdays = JD(seq(as.POSIXlt(input$seedDate),as.POSIXlt(input$seedDate)+(dim(val$data)[1]*86400),by='day'))
    jdays = JD(as.Date(val$data[,1]))
    daylength(input$lat,input$lon,jdays,-6)[,3]
  })
  output$LT50 <- renderPlot({
    out <- out()
    
    out = cbind(out, temperature = val$data[,2],daylength=daylengths())

    out = as.data.frame(out)
    out$LT50raw = sapply(out$LT50raw,min,-3)    
    resp = out[,'respProg']
    respSlope = sapply(1:length(resp),function(i){ifelse(i == 1,0,resp[i]-resp[i-1])})
    resp[respSlope > 0] = 1
    resp[respSlope == 0] = 0
    resp[respSlope < 0] = 1
    inds <- diff(c(0, resp))
    start <- out$time[inds == 1]
    end <- out$time[inds == -1]
    if (length(start) > length(end)) end <- c(end, tail(out$time, 1))
    rects <- data.frame(start=start, end=end, group=seq_along(start))
    
    p = ggplot(out, aes(x = time)) +
      geom_line(aes(y = LT50raw,color='Predicted LT50'),size=1,linetype=2,show.legend = TRUE) +
      geom_line(aes(y = temperature,color='Soil Temp. at Crown Depth'),size=1,show.legend = TRUE) +
      geom_vline(xintercept = out[which.max(sapply(out[, 'photoReqFraction'], min, 1)), 'time'], linetype = 3) +
      geom_text(
        aes(
          x = out[which.max(sapply(out[, 'photoReqFraction'], min, 1)), 'time'],
          label = paste("Maximum Photoperiod Saturation:", round(min(out[which.max(sapply(out[, 'photoReqFraction'], min, 1)), 'photoReqFraction'], 1) * 100, 2), "%", sep = ""),
          y = -20
        ),
        colour = "#228B22",
        angle = 90,
        hjust = 0,
        vjust = 0,
        size=5
      ) +
      # geom_vline(xintercept = out[which.max(sapply(out[, 'mflnFraction'], min, 1)), 'time'], linetype = 3) +
      annotate(geom='label_repel',x=out[which(floor(out[,'temperature']-out[,'LT50raw']) <= 0)[1],'time'],y=out[which(floor(out[,'temperature']-out[,'LT50raw']) <= 0)[1],'temperature'],label='Winterkill',
               fontface = 'bold', color = 'red',
               box.padding = unit(0.35, "lines"),
               point.padding = unit(0.5, "lines")
               ) +
      # geom_text(
      #   aes(
      #     x = out[which.max(sapply(out[, 'mflnFraction'], min, 1)), 'time'],
      #     label = paste("MFLN Requirement:", round(min(out[which.max(sapply(out[, 'mflnFraction'], min, 1)), 'mflnFraction'], 1) * 100, 2), "% Met", sep = ""),
      #     y = -20
      #   ),
      #   colour = "#228B22",
      #   angle = 90,
      #   size = 5,
      #   hjust= 0,
      #   vjust = 0
      # ) +
    geom_vline(xintercept = out[which.max(sapply(out[, 'vernProg'], min, 1)), 'time'], linetype = 3) +
      geom_text(
        aes(
          x = out[which.max(sapply(out[, 'vernProg'], min, 1)), 'time'],
          label = paste("Max Vernalization Saturation: ", round(min(out[which.max(sapply(out[, 'vernProg'], min, 1)), 'vernProg'], 1) * 100, 2), "%", sep = ""),
          y = -20
        ),
        colour = "#228B22",
        angle = 90,
        hjust = 0,
        vjust = 0,
        size=5
      )
      if(dim(rects)[1] > 0) {
      p = p + geom_rect(data=rects, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=-Inf,
                                                   ymax=Inf, group=group), color="transparent", fill="orange", alpha=0.3) +
      geom_text(data=rects, inherit.aes=FALSE,aes(x=start,y=-15,label='respiration'),angle=90,alpha=0.5,size=6,vjust=1)
      }
      if(val$x_coord > 0) {
        p = p + geom_vline(xintercept=val$x_coord,linetype=3) + 
          annotate(
            geom='text',
            label = paste(as.Date(input$seedDate)+out[val$x_coord,'time'],
                          '\ndaylength = ',out[val$x_coord,'daylength'], ' hours'
            ),
              x = max(out$time),
              y = max(out$temperature),
            size = 5,
            hjust= 1,
            vjust= 1
          ) +
          geom_label(data=out[val$x_coord,],size=5,mapping=aes(label=paste0(round(temperature,1),"°C"),x=time,y=temperature)) +
          geom_label(data=out[val$x_coord,],size=5,mapping=aes(label=paste0(round(LT50raw,1),"°C"),x=time,y=LT50raw)) 

      }
      p = p + scale_colour_manual("",values=c("Soil Temp. at Crown Depth"="blue","Predicted LT50"="orange")) +
    theme_minimal() + ylab( "Temperature (°C)") + xlab("Day") + theme(axis.text=element_text(size=16),axis.title=element_text(size=16,face='bold'),plot.title = element_text(size=16,face='bold'),legend.position='bottom',legend.text = element_text(size=16),panel.border = element_rect(colour = "grey", fill=NA, size=2),plot.background = element_rect(fill = "transparent",colour = NA)) + ggtitle(val$plotTitle)
    p
  },bg='transparent')
  observe({
    input$temperatureData
    isolate({
      # save new points added
      # add new points to data
      inFile <- input$temperatureData
      if (!is.null(inFile)) {
        d <- read.csv(file=inFile$datapath,header=TRUE)
        val$data <- d
      }
    })
  })
  observe({
    input$plot_dblclick
    isolate({
      # save new points added
      # add new points to data
      if(!is.null(input$plot_dblclick$x)) {
        d <- val$data
        day_dist = abs(d$t-input$plot_dblclick$x)
        width = 20
        weight.min = 1
        weight.max = 10
        s = max(which.min(day_dist)-floor(width/2),1)
        e = min(which.min(day_dist)+floor(width/2),length(day_dist))
        width = e-s+1
        if(!as.logical(width %% 2)) {
          x.lim = (width+1)
        } else {
          x.lim = width
        }
        weights = (dnorm((1:x.lim)-ceiling(x.lim/2))+1)*2
        d$crownTemp[s:e] = loess(y~x,data=data.frame(x=1:x.lim,y=c(d$crownTemp[s:(s+(floor(width/2)-1)-2)],rep(input$plot_dblclick$y,5),d$crownTemp[(e-(floor(width/2)-1)+2):e])),weights =weights,degree=2,span=0.5)$fitted
        val$x_coord <- 0
        val$data <- d
      }
    })
  })
  observe({
    input$selectVariety
    scoeff = coeff[coeff$V1==input$selectVariety,]
    val$plotTitle = paste(scoeff$V1,scoeff$V7,scoeff$V8)
    updateSliderInput(session,inputId='photoCoeff',value = scoeff$V5)
    updateSliderInput(session,inputId='photoCritical',value = scoeff$V6)
    # updateSliderInput(session,inputId='minDD',value = scoeff$V4)
    updateSliderInput(session,inputId='vernReq',value = scoeff$V3)
    updateSliderInput(session,inputId='LT50c',value = scoeff$V2)
  })
  observe({
    input$plot_brush
    isolate({
      # save new points added
      # add new points to data
      if(!is.null(input$plot_brush$xmin)) {
        d <- val$data
        t <- 1:length(val$data$t)
        #brushedPoints(d,input$plot_brush)
        day_min = abs(t-input$plot_brush$xmin)
        day_max = abs(t-input$plot_brush$xmax)
        s = max(which.min(day_min)-2,1)
        e = min(which.min(day_max)+2,length(day_max))
        width = e-s+1
        if(!as.logical(input$respiration))
          d$crownTemp[s:e] = loess(y~x,data=data.frame(x=1:width,y=d$crownTemp[s:e]),degree=1,span=2)$fitted
        if(as.logical(input$respiration))
          d$crownTemp[s:e] = 0
        val$x_coord <- 0
        val$data <- d
      }
    })
  })
  output$downloadData <- downloadHandler(
    filename = function() {
      paste("WCSM-data-", Sys.Date(), ".csv", sep="")
    },
    content = function(file) {
      write.csv(cbind(out(), temperature = val$data[,2],daylengths=daylengths()), file)
    }
  )
  output$map <- renderLeaflet({
    # Use leaflet() here, and only include aspects of the map that
    # won't need to change dynamically (at least, not unless the
    # entire map is being torn down and recreated).
    leaflet() %>%
    addProviderTiles(providers$Stamen.Terrain,
                     options = providerTileOptions(noWrap = TRUE)
    ) %>% setView(lng = input$lon,lat=input$lat,zoom = 4) %>% addMarkers(lng=input$lon,lat=input$lat) %>%
      addSearchOSM()
  })
  observe({
    click <- input$map_click
    if(is.null(click))
      return()
    updateNumericInput(session,'lat',value=click$lat)
    updateNumericInput(session,'lon',value=click$lng)
  })
  observe({
    input$plot_click
    isolate({
      # save new points added
      # add new points to data
      if(!is.null(input$plot_click$x)) {
        t = 1:length(val$data$t)
        #day_dist = abs(val$data$t-input$plot_click$x)
        #val$x_coord = val$data$t[which.min(day_dist)]
        day_dist = abs(t-input$plot_click$x)
        val$x_coord = t[which.min(day_dist)]
      }
    })
  })
  
})
